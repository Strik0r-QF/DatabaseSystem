\documentclass[10pt,UTF8]{book} %% ctexart

\title{\textbf{数据库系统基础}}
\author{钱锋\thanks{Email: strik0r.qf@gmail.com}${}^,$\thanks{
    西北工业大学软件学院, School of Software, Northwestern Polytechnical University, 西安 710072
}}

\usepackage{ctex}
\usepackage{graphicx}
\usepackage[toc]{multitoc}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{amsthm, amssymb, amsmath, mathrsfs, mhchem}
\usepackage{tikz,circuitikz}
\usetikzlibrary{decorations.markings, angles, quotes}
\usetikzlibrary{shapes,arrows.meta,positioning}
\usepackage{tikz-cd}
\usepackage{pgfplots}
\usepackage{tikz-3dplot}
\usepackage{extpfeil}
\usepackage{diagbox}
\usepackage{float}
\usepackage{hyperref}
\hypersetup{hidelinks,
    colorlinks = true,
    allcolors = black,
    pdfstartview = Fit,
    breaklinks = true}
\usepackage{caption}
\usepackage{enumitem}
\usepackage{siunitx}
\usepackage{subcaption}

\input{LaTeX_tem/fancyhdr_settings.tex}
\input{LaTeX_tem/titlesec_settings.tex}
\input{LaTeX_tem/geometry_settings.tex}
% \input{LaTeX_tem/geometry_b5_settings.tex}
\input{LaTeX_tem/mdframed_settings.tex}
\input{LaTeX_tem/listings_settings.tex}

\usepackage{smartdiagram} % 表格对角线
\everymath{\displaystyle}
\usepackage{tasks}

\begin{document}
\input{LaTeX_tem/theoremstyles.tex}
% 使用 IEEE 样式
\ctikzset{logic ports=ieee}
\pagestyle{empty}
\begin{titlepage}
    \thispagestyle{empty}
    \centering
        \vspace*{2cm}
        \includegraphics[width=0.5\textwidth]{pic/npu_2.png}\par
        \vspace{1em}
        \includegraphics[width=0.5\textwidth]{pic/npu_1.png}\par
    \vspace{1em}
        \begin{center}
            \Huge \heiti \textbf{数据库系统基础}

            Fundamentals of Database Systems
        \end{center}
        \vspace{17em}
        \begin{center}
        \songti
        \kaishu 软件学院 \, \heiti\textbf{钱锋} \quad \songti 编
        \vspace{0.5em}

    \today
    \end{center}
\end{titlepage}
\cleardoublepage
\maketitle
\cleardoublepage

\frontmatter
\newpage
\pagestyle{plain}
\makeatother

% 设置目录页的页码格式
\pagenumbering{roman} % 切换回罗马数字页码
\addtocontents{toc}{\protect\thispagestyle{empty}}
\pagestyle{plain}
{\small \tableofcontents}
\newpage
\thispagestyle{empty}
\cleardoublepage % 确保正文从奇数页开始


% 设置章节标题页的页眉和页脚为空白页样式
\makeatletter
\let\ps@plain\ps@empty
\makeatother

\mainmatter
\chapter{数据库简介}
% \section{数据库技术的起源与发展}

% \subsection{数据管理技术发展阶段}

\section{数据库与数据库管理系统}

\subsection{数据库的四个基本概念}

\textbf{数据} (data) 是描述客观事物的符号记录.



\textbf{数据库} (database) 
% 是相关数据的集合, 可以通过\textbf{数据} (data) 来记录我们
% 所知的现实情况, 并赋予他们隐含的含义. 数据库具有以下三个隐含属性:
% \begin{itemize}[itemsep=0pt]
%     \item 数据库\textbf{表示现实的某个方面}: 有时将现实世界的某个方面称之
%     为\textbf{微观世界} (miniworld) 或者\textbf{论域} 
%     (universe of discourse, UoD). 微观世界的改变将会反映在数据库中.
%     \item 数据库是具有某种内在含义的、逻辑上协调一致的数据的集合.
%     \item 数据库是处于特定目的而设计、构建以及填充数据的.
% \end{itemize}
% 概括地说, 
% 数据库
是长期存储在计算机内部的、有组织的、可共享的大量数据的集合, 数据库中的数据
按照一定的数据模型组织、描述和储存, 具有较小的冗余度、较高的数据独立性和易拓展性,
并可为各种用户所共享.

% 数据库可以具有任意的规模性和复杂性.



\textbf{数据库管理系统} (database management system, DBMS) 是一个用于定义、构造和
操作数据库和自爱不同的用户与应用之间共享数据库的通用软件系统
(general-purpose software system). 它允许用户创建和维护数据库.
% \begin{itemize}[itemsep=0pt]
%     \item \textbf{定义} (define): 为将要存储在数据库中的数据指定数据类型、结构和约束条件.
%     数据库定义和描述信息, 即\textbf{元数据} (meta-data) 也是由 DBMS 以数据库目录或字典
%     的形式存储的.
%     \item \textbf{构造} (construct): 在 DBMS 的控制之下将数据存储在某种存储媒介上.
%     \item \textbf{操作} (manipulate): 包括查询数据库以检索特定的数据、更新数据库以反映
%     微观世界的改变以及通过数据生成报表等.
%     \item \textbf{共享} (share): 允许多个用户和程序同时访问数据库.
%     \item \textbf{保护} (protection): 例如防止软硬件故障的系统保护以及防止未经授权
%     或恶意访问数据库的安全保护.
%     \item \textbf{维护} (maintain): 使得数据库系统可以在长时间内随着需求的变化而不断演化.
% \end{itemize}
% 应用程序 (application program) 通过向 DBMS 发送查询或数据请求来访问数据库. \textbf{查询}
% (query) 通过会执行数据检索; 而\textbf{事务} (transcation) 则用于执行从数据库中读取数据或者
% 将数据写入数据库中.

\textbf{数据库系统} (database system) 是由数据库、DBMS、应用程序 (application program)
和数据库管理员 (database administer, DBA) 组成的存储、管理、处理和维护数据的系统.

\begin{figure}[H]
    \centering
    

\tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        

\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,427); %set diagram left start at 0, and has height of 427

%Shape: Rectangle [id:dp01515462542343704] 
\draw   (100,63.5) -- (336,63.5) -- (336,346.5) -- (100,346.5) -- cycle ;
%Shape: Rectangle [id:dp9866371707331819] 
\draw   (127.25,150) -- (308.75,150) -- (308.75,249.5) -- (127.25,249.5) -- cycle ;
%Flowchart: Magnetic Disk [id:dp6221057101121902] 
\draw   (206,274.16) -- (206,319.34) .. controls (206,326.05) and (188.37,331.5) .. (166.63,331.5) .. controls (144.88,331.5) and (127.25,326.05) .. (127.25,319.34) -- (127.25,274.16)(206,274.16) .. controls (206,280.88) and (188.37,286.33) .. (166.63,286.33) .. controls (144.88,286.33) and (127.25,280.88) .. (127.25,274.16) .. controls (127.25,267.45) and (144.88,262) .. (166.63,262) .. controls (188.37,262) and (206,267.45) .. (206,274.16) -- cycle ;
%Flowchart: Magnetic Disk [id:dp8335122842260207] 
\draw   (308.75,274.16) -- (308.75,319.34) .. controls (308.75,326.05) and (291.12,331.5) .. (269.38,331.5) .. controls (247.63,331.5) and (230,326.05) .. (230,319.34) -- (230,274.16)(308.75,274.16) .. controls (308.75,280.88) and (291.12,286.33) .. (269.38,286.33) .. controls (247.63,286.33) and (230,280.88) .. (230,274.16) .. controls (230,267.45) and (247.63,262) .. (269.38,262) .. controls (291.12,262) and (308.75,267.45) .. (308.75,274.16) -- cycle ;
%Straight Lines [id:da6416908174630893] 
\draw [line width=1.5]    (218,44.5) -- (218,89.75) ;
\draw [shift={(218,93.75)}, rotate = 270] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (6.97,-3.35) -- (0,0) -- (6.97,3.35) -- cycle    ;
%Straight Lines [id:da39888614015754065] 
\draw [line width=1.5]    (218,128.75) -- (218,145) ;
\draw [shift={(218,149)}, rotate = 270] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (6.97,-3.35) -- (0,0) -- (6.97,3.35) -- cycle    ;
%Straight Lines [id:da49744353352368653] 
\draw [line width=1.5]    (221.61,251.23) -- (265.77,272.43) ;
\draw [shift={(269.38,274.16)}, rotate = 205.64] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (6.97,-3.35) -- (0,0) -- (6.97,3.35) -- cycle    ;
\draw [shift={(218,249.5)}, rotate = 25.64] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (6.97,-3.35) -- (0,0) -- (6.97,3.35) -- cycle    ;
%Straight Lines [id:da2751170640767556] 
\draw [line width=1.5]    (214.39,251.23) -- (170.23,272.43) ;
\draw [shift={(166.63,274.16)}, rotate = 334.36] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (6.97,-3.35) -- (0,0) -- (6.97,3.35) -- cycle    ;
\draw [shift={(218,249.5)}, rotate = 154.36] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (6.97,-3.35) -- (0,0) -- (6.97,3.35) -- cycle    ;

% Text Node
\draw (102,66.5) node [anchor=north west][inner sep=0.75pt]   [align=left] {Database System};
% Text Node
\draw    (118.5,93.75) -- (317.5,93.75) -- (317.5,128.75) -- (118.5,128.75) -- cycle  ;
\draw (218,111.25) node   [align=left] {\begin{minipage}[lt]{132.6pt}\setlength\topsep{0pt}
\begin{center}
Applications/Query
\end{center}

\end{minipage}};
% Text Node
\draw (129.25,153) node [anchor=north west][inner sep=0.75pt]   [align=left] {Database \\Management System};
% Text Node
\draw (130.25,293) node [anchor=north west][inner sep=0.75pt]   [align=left] {meta-data};
% Text Node
\draw (239.75,294) node [anchor=north west][inner sep=0.75pt]   [align=left] {Database};
% Text Node
\draw (157.5,17) node [anchor=north west][inner sep=0.75pt]   [align=left] {User/Programmer};


\end{tikzpicture}
\caption{一种简化的数据库系统环境}
\end{figure}

\subsection{数据管理技术的发展}





虽然数据库是当前数据管理最有效的方式之一, 在数据库技术出现之前, 数据管理还
经历了两个阶段, 分别是手工管理阶段和文件系统管理阶段.

% \begin{itemize}[itemsep=0pt]
%     \item \textbf{手工管理阶段}
%     \item \textbf{文件系统管理阶段}
%     \item \textbf{数据库系统管理阶段}
%     \item \textbf{大数据管理系统}
% \end{itemize}

\begin{table}[H]
    \centering
    \caption{不同数据管理技术发展阶段的特点}
    \begin{tabular}{p{0.1\textwidth}|p{0.1\textwidth}p{0.1\textwidth}p{0.15\textwidth}p{0.2\textwidth}p{0.2\textwidth}}
        \hline
        \textbf{发展阶段} & \textbf{年代背景} & \textbf{应用背景} & \textbf{硬件条件} & \textbf{软件条件} & \textbf{数据管理} \\ 
        \hline
        \textbf{手工管理} & 1950s 之前 & 科学计算 & 打孔卡片、磁带; \newline 没有磁盘 & 没有操作系统和专门的数据管理软件; \newline 数据交互按照批处理方式进行 & 数据与程序相互依赖; \newline 数据没有共享 \\ 
        \hline
        \textbf{文件管理} & 1950s-60s & 科学计算; \newline 数据管理 & 磁盘、磁鼓 & 操作系统下产生文件系统; \newline 数据实时在线处理 & 数据文件相互独立; \newline 数据共享困难, 冗余 \\ 
        \hline
        \textbf{数据库} & 1960s 之后 & 大规模数据管理 & 大容量磁盘 & 产生了专门的数据管理软件——数据库管理系统, 以满足不同的场景应用需求 & 实现数据的共享、透明 \\ 
        \hline
    \end{tabular}
\end{table}
\begin{figure}[H]
    \centering
    \begin{minipage}{0.3\textwidth}
        \centering
        \begin{tikzpicture}[scale=0.7]
            \draw (0,0) node{程序 1} ellipse (1cm and 0.5cm);
            \draw (1.5,0) -- (3.5,0);
            \draw (5,0) node{数据 1} ellipse (1cm and 0.5cm);
    
            \draw (0,-1.5) node{程序 2} ellipse (1cm and 0.5cm);
            \draw (1.5,-1.5) -- (3.5,-1.5);
            \draw (5,-1.5) node{数据 2} ellipse (1cm and 0.5cm);
    
            \draw (0,-3) node{程序 3} ellipse (1cm and 0.5cm);
            \draw (1.5,-3) -- (3.5,-3);
            \draw (5,-3) node{数据 3} ellipse (1cm and 0.5cm);
        \end{tikzpicture}
        \subcaption{手工管理阶段的程序和数据基本是一一对应的, 没有数据共享}
    \end{minipage}
    \begin{minipage}{0.5\textwidth}
        \centering
        \begin{tikzpicture}[scale=0.8]
            \draw (-1,0) node{程序 1} ellipse (1cm and 0.5cm);
            \draw (0,0) -- (1.5,-1.5);
            \draw (3.5,-1.5) -- (5,0);
            \draw (6,0) node{数据 1} ellipse (1cm and 0.5cm);
    
            \draw (-1,-1.5) node{程序 2} ellipse (1cm and 0.5cm);
            \draw (0, -1.5) -- (1.5,-1.5);
            \draw (3.5,-1.5) -- (5,-1.5);
            \draw (6,-1.5) node{数据 2} ellipse (1cm and 0.5cm);
    
            \draw (-1,-3) node{程序 3} ellipse (1cm and 0.5cm);
            \draw (0, -3) -- (1.5,-1.5);
            \draw (3.5,-1.5) -- (5,-3);
            \draw (6,-3) node{数据 3} ellipse (1cm and 0.5cm);
    
            \draw (2.5,-1.5) node{文件系统} ellipse (1cm and 0.5cm);
        \end{tikzpicture}
        \subcaption{在文件系统阶段, 数据文件相互独立但是共享困难}
    \end{minipage}

    \vspace{1em}

    \begin{minipage}{\textwidth}
        \centering
        \begin{tikzpicture}[scale=0.8]
            \draw (-1.5,0) node{程序 1} ellipse (1cm and 0.5cm);
            \draw (-0.5,0) -- (0.5,-1.5);
    
            \draw (-1.5,-1.5) node{程序 2} ellipse (1cm and 0.5cm);
            \draw (-0.5, -1.5) -- (0.5,-1.5);
            \draw (4.5,-1.5) -- (6,-1.5);
            \draw (7,-1.5) node{数据库} ellipse (1cm and 0.5cm);
    
            \draw (-1.5,-3) node{程序 3} ellipse (1cm and 0.5cm);
            \draw (-0.5, -3) -- (0.5,-1.5);
    
            \draw (2.5,-1.5) node{数据库管理系统} ellipse (2cm and 0.5cm);
        \end{tikzpicture}
        \subcaption{数据库系统阶段实现了焦点分离}
    \end{minipage}
    \caption{数据库技术的不同阶段的特点}
\end{figure}

\section{数据模型 \quad 数据库系统的模式架构}

\subsection{数据模型分类}

数据模型分为\textbf{概念数据模型} (conceptual data model)、
\textbf{物理数据模型} (physical data model) 和介于二者之间的\textbf{实现数据模型}
(implementational data model).
\begin{itemize}[itemsep=0pt]
    \item 概念数据模型按照用户的观点来为数据和信息进行建模.
    \item 物理数据模型描述了在计算机存储介质上存储数据的细节.
\end{itemize}

概念数据模型使用实体、属性和关系等概念来进行建模. 我们会在第 \ref{chap: ER model} 章中介绍
\textbf{实体—关系模型} (entity-relationship model, ER model) 和这些有关的概念.

实现数据模型包括广泛使用的\textbf{关系数据模型} (relational data model) 以及
已经过时的网状模型 (network model) 和层次模型 (hierachical model), 还有一些更高级的实现
数据模型的新家族成员, 例如\textbf{对象数据模型} (object data model).

\subsection{数据库系统的模式架构}

\begin{figure}[H]
    \centering
    % 图的内容


    \tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        

    \begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
    %uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300
    
    %Straight Lines [id:da6888236647331167] 
    \draw  [dash pattern={on 4.5pt off 4.5pt}]  (194,154.5) -- (194,203.5) ;
    %Straight Lines [id:da5140114108378135] 
    \draw  [dash pattern={on 4.5pt off 4.5pt}]  (459,154.5) -- (459,203.5) ;
    %Straight Lines [id:da9015634759886653] 
    \draw    (99,220.5) -- (130,220.5) ;
    \draw [shift={(133,220.5)}, rotate = 180] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (5.36,-2.57) -- (0,0) -- (5.36,2.57) -- cycle    ;
    %Straight Lines [id:da15947017273673214] 
    \draw    (255,220.5) -- (423.5,220.5) ;
    \draw [shift={(426.5,220.5)}, rotate = 180] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (5.36,-2.57) -- (0,0) -- (5.36,2.57) -- cycle    ;
    %Straight Lines [id:da12741905382504892] 
    \draw    (235,130) -- (277.5,130) ;
    \draw [shift={(280.5,130)}, rotate = 180] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (5.36,-2.57) -- (0,0) -- (5.36,2.57) -- cycle    ;
    %Straight Lines [id:da8746216303282328] 
    \draw    (401.5,130) -- (415,130) ;
    \draw [shift={(418,130)}, rotate = 180] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (5.36,-2.57) -- (0,0) -- (5.36,2.57) -- cycle    ;
    %Straight Lines [id:da5170374392849098] 
    \draw  [dash pattern={on 4.5pt off 4.5pt}]  (459,85.5) -- (459,107.5) ;
    %Straight Lines [id:da5715165373295344] 
    \draw  [dash pattern={on 4.5pt off 4.5pt}]  (341,85.5) -- (341,107.5) ;
    %Straight Lines [id:da7700125694774308] 
    \draw  [dash pattern={on 4.5pt off 4.5pt}]  (194,85.5) -- (194,107.5) ;
    
    % Text Node
    \draw    (26,208) -- (99,208) -- (99,233) -- (26,233) -- cycle  ;
    \draw (29,212) node [anchor=north west][inner sep=0.75pt]   [align=left] {\begin{minipage}[lt]{46.94pt}\setlength\topsep{0pt}
    \begin{center}
    real world
    \end{center}
    
    \end{minipage}};
    % Text Node
    \draw    (133,208) -- (255,208) -- (255,233) -- (133,233) -- cycle  ;
    \draw (136,212) node [anchor=north west][inner sep=0.75pt]   [align=left] {\begin{minipage}[lt]{80.39pt}\setlength\topsep{0pt}
    \begin{center}
    information world
    \end{center}
    
    \end{minipage}};
    % Text Node
    \draw    (426.5,208) -- (491.5,208) -- (491.5,233) -- (426.5,233) -- cycle  ;
    \draw (429.5,212) node [anchor=north west][inner sep=0.75pt]   [align=left] {\begin{minipage}[lt]{41.28pt}\setlength\topsep{0pt}
    \begin{center}
    machine
    \end{center}
    
    \end{minipage}};
    % Text Node
    \draw (156,111) node [anchor=north west][inner sep=0.75pt]   [align=left] {\begin{minipage}[lt]{53.19pt}\setlength\topsep{0pt}
    \begin{center}
    conceptual\\data model
    \end{center}
    
    \end{minipage}};
    % Text Node
    \draw (421,111) node [anchor=north west][inner sep=0.75pt]   [align=left] {\begin{minipage}[lt]{53.19pt}\setlength\topsep{0pt}
    \begin{center}
    physical\\data model
    \end{center}
    
    \end{minipage}};
    % Text Node
    \draw (283.5,111) node [anchor=north west][inner sep=0.75pt]   [align=left] {\begin{minipage}[lt]{79.84pt}\setlength\topsep{0pt}
    \begin{center}
    implementational\\data model
    \end{center}
    
    \end{minipage}};
    % Text Node
    \draw (166.5,43) node [anchor=north west][inner sep=0.75pt]   [align=left] {\begin{minipage}[lt]{39.02pt}\setlength\topsep{0pt}
    \begin{center}
    external\\schema
    \end{center}
    
    \end{minipage}};
    % Text Node
    \draw (303.25,43) node [anchor=north west][inner sep=0.75pt]   [align=left] {\begin{minipage}[lt]{52.06pt}\setlength\topsep{0pt}
    \begin{center}
    conceptual\\schema
    \end{center}
    
    \end{minipage}};
    % Text Node
    \draw (431.5,43) node [anchor=north west][inner sep=0.75pt]   [align=left] {\begin{minipage}[lt]{38.44pt}\setlength\topsep{0pt}
    \begin{center}
    internal\\schema
    \end{center}
    
    \end{minipage}};
    
    
    \end{tikzpicture}
    \caption{数据库系统的模式架构}
    \label{数据库系统的模式架构}
\end{figure}

数据库系统的\textbf{内模式} (internal schema) 属于数据库系统的\textbf{内层} (internal level),
它描述了数据库的物理存储结构, 使用物理数据模型.

\textbf{概念模式} (conceptual schema) 属于数据库系统的\textbf{概念层} (conceptual level),
它专注于描述实体、数据类型、关系、用户操作以及约束, 使用实现数据模型.

\textbf{外模式} (external schema) s呼吁数据库系统的\textbf{外层} (external level)
或\textbf{视图层} (view level), 它针对特定用户组来描述感兴趣的数据库的一部分, 并隐藏数据库的其他部分.

在不同的层次之间存在着\textbf{映射} (mapping), 外层—概念层映射实现外层与概念层的请求和结果之间的
转换, 概念层—内层映射则实现概念层与内层的请求和结果之间的转换.

\subsection{数据独立性}

\textbf{数据独立性} (data independence) 是指, 当改变数据库系统某一层上的模式时,
无需改变其上层的模式. 因此数据独立性又分为\textbf{逻辑数据独立性} (logical data independence)
和\textbf{物理数据独立性} (physical data independence).
当某一层的模式改变时, 数据独立性保证了更高层上的模式可以保持不变, 只需要更改两个层次之间的映射即可.
这为数据库的设计、使用和维护带来了极大的便利.

\chapter{实体—联系模型}
\label{chap: ER model}

\begin{example}
    CBA 赛事包括球队 (team)、球员 (player) 和比赛 (game) 的信息. 
    每个球队有唯一的编号 (tNo)、名称 (tName) 和所属城市 (tCity).
    每个球队有多名球员, 每名球员有唯一的编号 (pNo)、姓名 (pName)、位置
    (pPosition)、体重 (pWeight) 和年龄 (pAge).
    每场比赛有唯一的编号 (gNo)、日期 (gDate)、地点 (gLocation) 和主客场球队.
    每场比赛有多个球员参与, 每个球员在比赛中有特定的表现数据, 例如得分 (pgPoints)、
    助攻 (pgAssists) 和篮板 (pgRebounds).
    根据以上信息构造的满足数据需求的实体—联系 (ER) 模型 
    如图 \ref{example-er:team-player-game} 所示.
    \begin{figure}[H]
        \centering
        \includegraphics*[width=\textwidth]{pic/CBA赛事.png}
        \caption{CBA 赛事的 E-R 建模}
        \label{example-er:team-player-game}
    \end{figure}
    上图中需要特别说明的是, 一场比赛的主客场球队是根据主场 (home) 和客场 (away)
    关系来确定的.
\end{example}

\begin{example}
    某医院有多个科室 (department), 科室包含有相关编号 (dNo) 和名称 (dName).
    每个科室有多名医生 (doctor), 每名医生有各自的工号 (eNo)、姓名 (eName)、
    出生日期 (eBirthDate)、工龄 (eYearsOfService)、民族 (eEthicity)、
    籍贯 (ePlaceOfOrigin) 等信息.
    每名医生只能在一个科室中工作, 但可以参与多个医学项目 (medical project,
    即 project), 每个项目可由多名医生参加.
    参加相应医学项目时, 有相关的项目周期 (pDuration)、名称 (pName)、项目经费
    (pBudget)、项目简介 (pInfo) 等信息.
    根据以上信息构造的满足数据需求的实体—联系 (ER) 模型 
    如图 \ref{example-er:doctor-department-project} 所示.
    \begin{figure}[H]
        \centering
        % 图的内容
        \includegraphics*[width=\textwidth]{pic/ER_医院科室.png}
        \caption{医院内部的 E-R 建模}
        \label{example-er:doctor-department-project}
    \end{figure}
    为了避免混淆, 我们在定义医生的有关属性时采用了 e 开头 (毕竟医生从某种角度上讲
    可以看作是医院的雇员, 即 employee).
\end{example}

\chapter{关系数据模型和关系数据库约束}




\chapter{关系代数和关系演算}

本章我们讨论关系模型的两种形式话语言, 分别是关系代数和关系演算.

\textbf{关系代数} (relational algebra) 是形式话关系模型的基本操作集,
这些操作使用户能够将基本的检索请求指定为关系代数表达式.

\textbf{关系演算} (relational calculus) 则提供了用于指定关系查询的
更高级的声明性语言.

我们在本章中先介绍这些关系代数的运算规则, 然后再通过具体的例子的形式
来解释这些运算的相关使用注意事项.

\section{一元关系运算: 选择和投影}

\subsection{选择运算}

分离公理告诉我们, 对于集合 $A$, 我们总能根据性质 $P$ 来确定
$A$ 的一个子集, 这个子集中的所有元素都是 $A$ 中满足性质 $P$ 的元素. 由此我们
得到了关系的选择运算. 它从一个关系当中, “筛选” 出符合某个条件的元组来, “过滤”
掉那些不符合条件的元组.

\begin{definition}[选择运算]
    设 $\mathcal{R}$ 是一个关系, $t \in \mathcal{R}$ 是关系 $\mathcal{R}$ 的一个元组,
    $p(t)$ 是在关系 $\mathcal{R}$ 的属性上指定的一个 Bool 表达式. 那么子集
    \[ \sigma_{p(t)}(\mathcal{R}) := \left\{
        t \in \mathcal{R} | p(t) = \mathrm{True}
    \right\} \]
    称为关系 $\mathcal{R}$ 在条件 $p(t)$ 下的\textbf{选择} (selection)
    或者\textbf{过滤器} (filter), Bool 表达式 $p(t)$ 称为\textbf{选择条件}
    (selection condition).
\end{definition}
\begin{remark}
    $\mathcal{R}$ 是一个关系, 也可以是一个\textbf{关系代数表达式}
    (relational algebratic expression). 这是因为关系代数表达式是有关系运算
    序列构成的, 其结果也是一个关系.
\end{remark}
\begin{remark}
    关系 $\mathcal{R}$ 的选择 $\sigma_{p(t)} (\mathcal{R})$ 的属性与
    $\mathcal{R}$ 的属性相同, 这是因为选择运算并没有改变关系 $\mathcal{R}$
    中元组的分量.
\end{remark}
\begin{remark}
    选择条件 $p(t)$ 一般是由许多的\textbf{子句} (clause) 组成的,
    子句之间可以用 $\wedge, \vee, \lnot$ 进行复合和连接.
\end{remark}
\begin{remark}
    并不是所有的关系符号都可以用在选择条件的构造中, 例如, 如果被选择的属性
    的域是一个无序域的话, 那显然不可以利用 $\leqslant$ 关系来进行选择.
\end{remark}

从选择运算的定义立即得到,
选择运算符 $\sigma$ 是一个\textbf{一元} (unary) 运算符, 选择运算将单独应用于
每个元组. 这是因为我们在进行关系的选择运算的时候, 往往是遍历关系 $\mathcal{R}$
的所有元组 $t$, 分别检验它们是否满足选择条件 $p(t)$.

此外, 由于选择运算最终确定的是关系 $\mathcal{R}$ 的一个子集, 而关系 $\mathcal{R}$
在数据库系统的范畴内是一个有限集合, 因此我们知道对于任意的选择条件 $p$, 都有
\[ \sigma_p(\mathcal{R}) \leqslant |\mathcal{R}|. \]
它的意思是说, 对一个关系做选择运算, 不可能得到比原来更多的元组. 从常理上来说
这是容易理解的, 从一个有限集合中排除掉一些不符合条件的元素后, 剩下的部分怎么会
反而变多呢? 这又不是教育改革双减. 选择运算的这一性质, 让我们得以自然的引出
下面的概念:

\begin{definition}[选中率]
    设 $\sigma_p(\mathcal{R})$ 是基于选择条件 $p$ 对关系 $\mathcal{R}$
    的一个选择. 我们称数 $|\sigma_p(\mathcal{R})|/|\mathcal{R}|$
    为条件 $p$ 的\textbf{选中率} (selectivity), 即
    \[ \mathrm{selectivity}(p,\mathcal{R}) =
    \dfrac{|\sigma_p(\mathcal{R})|}{|\mathcal{R}|}, \]
    它是两个有限集合 $\sigma_p(\mathcal{R})$, $\mathcal{R}$ 中元素数量的比值.
\end{definition}

我们要进一步说明的是, 选择运算是\textbf{可交换} (commutative) 的,
这是因为我先做一次选择可以确定一个子集, 在这个选择的基础上再做一次选择,
本质上就是按照条件 $p_1$ 和 $p_2$ 的合取 $p_1 \wedge p_2$ 来进行选择.
因此根据命题的合取的交换性, 我们知道选择运算是可交换的, 而且若干个选择运算
构成的关系代数表达式可以利用选择条件的合取合并成一次选择运算, 即
\[ \sigma_{p_n}(\sigma_{p_{n-1}}(\cdots \sigma_{p_2}(\sigma_{p_1}(\mathcal{R}))))
= \sigma_{\bigwedge_{k=1}^n p_k}(\mathcal{R}). \]

\begin{example}
    假设 EMPLOYEE 是一个关系, 它的元组给定了某企业中的一个员工的信息,
    它的属性是 No, Name, Sex 和 Salary. 那么月薪在 5000 元以上的选择
    就可以被表示为 $\sigma_{\mathrm{Salary} > 5000}(\mathrm{EMPLOYEE})$.
    性别为 “武装直升机” (armed helicopter) 的选择就可以被表示为
    $\sigma_{\mathrm{Sex} = \mathrm{'armed\_helicpter'}}(\mathrm{EMPLOYEE})$.
    如果我们要查询月薪在 5000 元以上, 且性别为武装直升机的数据, 那么我们可以
    定义查询 \[ \sigma_{(\mathrm{Salary} > 5000)
    \wedge(\mathrm{Sex = 'armed\_helicopter'})}(\mathrm{EMPLOYEE}). \]
\end{example}

\subsection{投影运算}

投影运算从关系中选择某些列, 并且会丢弃其他的列. 如果只对一个关系的某些属性感兴趣,
就可以利用投影运算, 将关系投影到这些属性上.

\begin{definition}[投影运算]
    设 $\mathcal{R}$ 是一个关系, $[A_1, A_2, \cdots, A_n]$ 是关系
    $\mathcal{R}$ 的属性,
    那么
    \[ \pi_{A_i}(\mathcal{R}) = \left\{
       a_i  | t\in\mathcal{R}
    \right\}. \]
    称为关系 $\mathcal{R}$ 在属性 $A_i$ 上的投影.
\end{definition}

我们可以把关系的投影运算推广到有限个属性的情形, 如果属性列表 $A_1, A_2, \cdots, A_n$
是关系 $\mathcal{R}$ 的 $n$ 个属性. 那么
\[ \pi_{[A_1, A_2, \cdots, A_n]} = \left\{
    [a_1, a_2,\cdots, a_n] | t \in \mathcal{R}
\right\} \]
就是关系 $\mathcal{R}$ 在属性列表 $A_1, A_2, \cdots, A_n$
上的投影, 其中每一个元组中各个属性的值出现的顺序与在属性列表中指定的顺序相同.

由于集合中的元素是互异的, 所以对关系 $\mathcal{R}$ 的非键属性进行投影,
就会有重复的元组, 而这些元组在集合中被视为同一个元素. 这就是投影运算的
\textbf{重复消除} (duplicate elimination) 现象.
\begin{remark}
    如果不消除重复元素, 那么得到的就不是一个集合, 而是包含重复元组的\textbf{包},
    这在形式化关系模型中是不允许的, 但是在 SQL 中是允许的. 在 SQL 中,
    如果在查询的 \lstinline|SELECT| 子句投影了一个属性列表后, 不使用
    \lstinline|DISTINCT| 来从查询中删除关键字, 那么查询结果将会包含重复的
    元组.
\end{remark}
\begin{example}
    某高校数据库系统中有以下关系:
    \begin{table}[H]
        \centering
        \caption{COURSE}
        \begin{tabular}{cc}
            \hline
            \textbf{Course} & \textbf{Department} \\ 
            \hline
            Mathematical Analysis & Math \\ 
            Advanced Algebra & Math \\ 
            Fundamentals of Computer Programming & Computer \\ 
            Introduction to Software Engineering & Software \\
            \hline
        \end{tabular}
    \end{table}
    执行投影运算将关系 COURSE 投影到属性 Department 上,
    就可以获得所有课程的开课部门组成的集合. 这就是说, 我们有查询结果
    \[ \pi_\mathrm{Department}(\mathrm{COURSE}) = \left\{
        [\mathrm{Math}], [\mathrm{Computer}], [\mathrm{Software}]
    \right\}. \]
    注意到数学分析 (Mathematical Analysis) 和高等代数 (Advanced Algebra)
    两门课程都是数学与统计学院 (Math) 开设的, 但是在投影运算投影到开课部门
    (Department) 属性后, 它们就成为一个元素了.
\end{example}

投影运算得到的元组数量总是少于关系 $\mathcal{R}$ 中的元组数量. 这是因为, 如
先前所述, 当投影到一个关系 $\mathcal{R}$ 的非键属性时, 得到的是去除了
重复元素之后的集合. 但是当我们投影到某个键属性上时, 得到的元组数量就会等于
关系 $\mathcal{R}$ 的元组数量了.

\begin{exercise}
    举例说明投影运算不具有可交换性.
\end{exercise}
\begin{exercise}
    假设 $\mathrm{list1} := [A_1, A_2, \cdots, A_n]$ 是关系 $\mathcal{R}$ 的一个属性列表,
    $\mathrm{list2} := [A_{i1}, A_{i2}, \cdots, A_{ir}]$ 是它的一个子列表.
    尝试说明为什么
    \[ \pi_\mathrm{list1}\left(\pi_\mathrm{list2}(\mathcal{R})\right) \]
    是一个错误的关系代数表达式.
\end{exercise}

\subsection{RENAME 运算}

为了建立一个查询, 我们可能需要重复进行多次关系代数运算, 从而得到一个
关系代数表达式. 这种多个运算及其嵌套得到的表达式称为\textbf{内联表达式}
(in-line expression), 但有时, 一次应用一个运算, 并将中间结果用合适的名称
来表示, 会使得整个过程更简洁, 这与程序代码追求可读性是一样的. 这就需要对
中间关系和结果关系及其属性进行\textbf{重命名} (rename). 于是我们定义了
如下运算:

\begin{definition}[重命名运算]
    设 $\mathcal{R}$ 是一个关系, $[A_1, A_2, \cdots, A_n]$ 是关系
    $\mathcal{R}$ 的属性. 那么 $\rho_{\mathcal{S}(B_1, B_2, \cdots, B_n)}(\mathcal{R})$
    是一个关系, 它表示
    \[ 
    \left\{
        [b_1, b_2, \cdots, b_n] | \exists! t \in \mathcal{R}
        \left( a_1 = b_1, a_2=b_2, \cdots, a_n = b_n \right)
    \right\} \]
    称为关系 $\mathcal{R}$ 的一个\textbf{重命名} (rename),
    其中 $\rho$ 称为 RENAME 运算符,
    $\mathcal{S}$ 为新的关系, $[B_1, B_2, \cdots, B_n]$ 为新的属性,
    新的属性与 $[A_1, A_2, \cdots, A_n]$ 在顺序上是相同的.
\end{definition}

我们也可以使用二元运算符的赋值运算来进行关系的重命名, 我们认为执行语句
\[ \mathcal{S}[B_1, B_2, \cdots, B_n] \longleftarrow 
\mathcal{R}[A_1, A_2, \cdots, A_n] \]
得到的关系 $\mathcal{S}$ 与关系 
$\rho_{\mathcal{S}(B_1, B_2, \cdots, B_n)}(\mathcal{R})$
是等价的.

\section{集合论中的关系代数运算}

\subsection{并集、交集和差集}

可以使用集合论运算的方法来处理两个元组的集合, 即两个关系. 包括并集 (union)、
交集 (intersection) 和差集 (difference, 或称为 except). 但参与这三种
运算的两个关系必须具有相同的\textbf{元组类型} (type of tuple). 于是我们
首先定义两个关系的类型兼容性:

\begin{definition}
    对于关系 $\mathcal{R}(A_1, A_2, \cdots, A_n)$ 和 $\mathcal{S}
    (B_1, B_2, \cdots, B_n)$, 如果同时满足下列条件:
    \begin{enumerate}[label={${\arabic*}^\circ$}, itemsep=0pt]
        \item $\deg \mathcal{R} = \deg \mathcal{S}$, 
        即它们具有相同的度 (degree, 即属性个数) $n$;
        \item $\forall i \in [a,n]\cap\mathbb{Z}\left(
            \mathrm{dom}(A_i) = \mathrm{dom}(B_i)
        \right)$, 即每个对应的属性都具有相同的域 (domain),
    \end{enumerate}
    则称关系 $\mathcal{R}$ 和关系 $\mathcal{S}$ 是\textbf{类型兼容}
    (type comtatible) 或\textbf{并兼容} (union compatible) 的.
\end{definition}

\begin{definition}
    设 $\mathcal{R}, \mathcal{S}$ 是两个并兼容的关系, 定义
    \begin{enumerate}[label={${\arabic*}^\circ$}, itemsep=0pt]
        \item 关系的并: $\mathcal{R} \cup \mathcal{S} := \left\{
            t | (t \in \mathcal{R}) \vee (t \in \mathcal{S})
        \right\}$, 其中包括 $\mathcal{R}$ 或 $\mathcal{S}$ 或它们二者
        中的所有元组;
        \item 关系的交: $\mathcal{R} \cap \mathcal{S} := \left\{
            t | (t \in \mathcal{R}) \wedge (t \in \mathcal{S})
        \right\}$, 其中包括既在 $\mathcal{R}$ 中又在 $\mathcal{S}$
        中的所有元组;
        \item 关系的差: $\mathcal{R} - \mathcal{S} := \left\{
            t | (t \in \mathcal{R}) \wedge (t \notin \mathcal{S})
        \right\}$, 其中包括在 $\mathcal{R}$ 中但不在 $\mathcal{S}$
        中的所有元组.
    \end{enumerate}
\end{definition}
\begin{remark}
    并运算和交运算都是可交换、可结合 (associative) 的.
\end{remark}

\subsection{Descartes 积运算}

\begin{definition}[Descartes 积]
    设 $\mathcal{R}(A_1, A_2, \cdots, A_m)$, $\mathcal{S}
    (B_1, B_2, \cdots, B_n)$ 是两个关系, 
    $(a_1, a_2, \cdots, a_m)$ 和
    $(b_1, b_2, \cdots, b_n)$ 是它们的元组.
    那么
    \[ \mathcal{R} \times \mathcal{S} := \left\{
        (a_1, a_2, \cdots, a_m, b_1, b_1, \cdots, b_n)
        = (r,s) | (r= \in \mathcal{R})
        \wedge (s =  \in \mathcal{S})
    \right\} \]
    称为关系 $\mathcal{R}$ 与关系 $\mathcal{S}$ 的 \textbf{Descartes 积}
    (Descartesian product).
\end{definition}

\newpage
\section{关系代数查询 \quad 作业}

已知关系模式
\begin{lstlisting}
department(dNo, dName, officeRoom, homePage)
student(sNo, sName, sex, age, dNo)
course(cNo, cName, cPNo, credit, dNo) // cPNo 为先修课程
sc(sNo, cNo, score, recordDate)
\end{lstlisting}
用关系代数完成以下查询.

\subsection{基本查询}

\begin{example}
    所有年龄小于 $18$ 岁的男生姓名.
    \begin{figure}[H]
        \centering


        \tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        

        \begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
        %uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300
        
        
        % Text Node
        \draw (160,206.4) node [anchor=north west][inner sep=0.75pt]    {$\mathrm{student}$};
        % Text Node
        \draw (96,140.4) node [anchor=north west][inner sep=0.75pt]    {$\sigma \mathrm{_{\mathrm{age< 18\ \land \ sex='\text{male} '}}( student)}$};
        % Text Node
        \draw (65.5,73.4) node [anchor=north west][inner sep=0.75pt]    {$\boxed{\pi \mathrm{_{sName}}( \sigma \mathrm{_{\mathrm{age< 18\ \land \ sex='\text{male} '}}( student)})}$};
        % Connection
        \draw    (189.5,202) -- (189.5,166) ;
        \draw [shift={(189.5,163)}, rotate = 90] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (5.36,-2.57) -- (0,0) -- (5.36,2.57) -- cycle    ;
        % Connection
        \draw    (189.5,136) -- (189.5,99) ;
        \draw [shift={(189.5,96)}, rotate = 90] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (5.36,-2.57) -- (0,0) -- (5.36,2.57) -- cycle    ;
        
        \end{tikzpicture}
        \caption{年龄小于 $18$ 岁的男生的姓名的查询树}
        \label{example-query_tree: age<18, sex=male}
    \end{figure}
    \begin{cmt}
        我们可以使用如图 \ref{example-query_tree: age<18, sex=male} 
        所示的查询树来表达关系代数表达式的建立过程, 在该查询中, 我们首先
        筛选出了所有年龄小于 $18$ 且性别为男性的 student 元组,
        然后将其投影到姓名属性上.
    \end{cmt}
\end{example}

\begin{example}
    查询所有学分大于 $3$ 的课程名称.
    \begin{sol}
        此后对于一些简单的查询, 我们不再给出查询树,
        为了获得查询结果, 我们首先需要在 course 关系中筛选出学分大于 $3$ 的元组
        来, 即 $\sigma_{\mathrm{credit > 3}}(\mathrm{course})$,
        然后我们将其投影到 cName 属性上, 因此关系代数表达式
        \[ \pi_{\mathrm{cName}}\left(
            \sigma_{\mathrm{credit > 3}}(\mathrm{course})
        \right) \] 
        即为所求.
    \end{sol}
\end{example}

\begin{example}
    查询没有先修课程的课程名称.
    \begin{sol}
        为了获取查询结果, 我们需要考虑 course 中没有先修课程的元组, 即
        \[ \sigma_{\mathrm{cPNo = NULL}}(\mathrm{course}), \]
        然后将其投影到 cName 属性上, 因此
        \[ \pi_{\mathrm{cName}}\left(
            \sigma_{\mathrm{cPNo = NULL}}(\mathrm{course})
        \right) \]
        即为所求. 注意在 SQL 中表达一个值是否为 \lstinline|NULL| 通常采用
        \lstinline|IS| 和 \lstinline|IS NOT| 关系符, 但为了方便起见,
        我们关系代数表达式中我们采用相等运算符 $=$.
    \end{sol}
\end{example}

\subsection{连接查询}

\begin{example}
    查询 “信息学院” 所有学生的姓名.
    \begin{sol}
        为了得到查询结果, 我们首先获取 department 表中信息学院
        (School of Information Science, SIS)
        所在的元组,
        并将其投影到 dNo 属性上,
        \[ \pi_\mathrm{dNo}\left(
            \sigma_\mathrm{dName='SIS'} (\mathrm{department})
        \right),\]
        接下来将其与 student 表基于 dNo 属性进行自然连接, 
        \[ \mathrm{student} \Join_\mathrm{dNo}
        \pi_\mathrm{dNo}\left(
            \sigma_\mathrm{dName='SIS'} (\mathrm{department})
        \right), \]
        所得到的就是
        信息学院中所有学生的信息. 这是因为不满足 dNo 等于学院的元组将会
        作为悬浮的元组被剔除,
        将其投影到 sName 属性上,
        \[ \pi_\mathrm{sName} \left(
            \mathrm{student} \Join_\mathrm{dNo}
        \pi_\mathrm{dNo}\left(
            \sigma_\mathrm{dName='SIS'} (\mathrm{department})
        \right)
        \right) \]
        即为所求.
    \end{sol}
    \begin{cmt}
        由于在 \LaTeX 公式中输入汉字较为不便, 我们采用英文来作为名称
        给定关系代数表达式.
    \end{cmt}
    \begin{cmt}
        连接运算总是消耗时间的, 因此我们尽量减少参与连接运算的元组的个数
        以获得更高的执行速度, 但是由于本节中我们主要关注给出能够得到查询结果
        的有效的关系代数表达式, 因此本节中我们给出的关系代数表达式
        不一定是效率最优的.
    \end{cmt}
\end{example}

\begin{example}
    查询所有具有不及格记录的学生姓名.
    \begin{sol}
        为了得到查询结果, 我们首先需要将学生的姓名 “附加” 到 sc 表中,
        而附加这一字段需要参照 sNo 属性, 因此我们首先把 student 表
        投影到 sNo 和 sName 属性上,
        \[ \pi_{\mathrm{sName, sNo}}(\mathrm{student}), \]
        接下来, 利用 sNo 属性, 将 $\pi_{\mathrm{sName, sNo}}(\mathrm{student})$
        与 sc 表做一个自然连接,
        \[ \mathrm{sc} \Join_\mathrm{sNo}
        \pi_{\mathrm{sName, sNo}}(\mathrm{student}), \]
        所得到的表实际上就是在 sc 表中新增了 sName 字段的结果.
        接下来, 我们筛选出课程考核不及格的元组,
        \[ \sigma_{\mathrm{scoer} < 60}\left(
            \mathrm{sc} \Join_\mathrm{sNo}
        \pi_{\mathrm{sName, sNo}}(\mathrm{student})
        \right), \]
        然后把它投影带 sName 属性上, 由于投影运算将会自然地消除重复的元组,
        所以
        \[ \pi_\mathrm{sName} \left(
            \sigma_{\mathrm{scoer} < 60}\left(
            \mathrm{sc} \Join_\mathrm{sNo}
        \pi_{\mathrm{sName, sNo}}(\mathrm{student})
        \right)
        \right) \]
        即为所求.
    \end{sol}
\end{example}

\begin{example}
    查询 “信息学院” 所有年龄小于 18 岁的女生的姓名.
    \begin{sol}
        为了得到查询结果, 我们首先获取 department 表中信息学院
        (School of Information Science, SIS)
        所在的元组,
        并将其投影到 dNo 属性上,
        \[ \pi_\mathrm{dNo}\left(
            \sigma_\mathrm{dName='SIS'} (\mathrm{department})
        \right),\]
        接下来我们从 student 表中筛选出年龄小于 18 岁且年龄为女的元组,
        \[ \sigma_\mathrm{age < 18 \wedge sex='Female'} \left(
            \mathrm{student}
        \right), \]
        这是 student 表中所有的未成年女生组成的子表,
        我们接下来将其与信息学院的元组进行自然连接,
        \[ \sigma_\mathrm{age < 18 \wedge sex='Female'} \left(
            \mathrm{student}
        \right) \Join_\mathrm{dNo} \pi_\mathrm{dNo}\left(
            \sigma_\mathrm{dName='SIS'} (\mathrm{department})
        \right), \]
        由于 dNo 不对应于信息学院的 student 元组
        会被自然连接运算作为悬浮的元组剔除, 因此
        这就得到了信息学院中所有未成年女生的记录, 接下来将其
        投影到 sName 属性上, 
        \[ \pi_\mathrm{sName} \left(
            \sigma_\mathrm{age < 18 \wedge sex='Female'} \left(
            \mathrm{student}
        \right) \Join_\mathrm{dNo} \pi_\mathrm{dNo}\left(
            \sigma_\mathrm{dName='SIS'} (\mathrm{department})
        \right)
        \right) \]
        即为所求.
    \end{sol}
\end{example}

\begin{example}
    查询所有选修了 “数据库” (Datbase System, BDS) 的学生姓名.
    \begin{sol}
        为了得到查询结果, 我们首先获取 course 中数据库课程的元组,
        \[ \sigma_\mathrm{cName='DBS'} (\mathrm{course}), \]
        接下来, 将其投影到 cNo 属性上,
        \[ \pi_\mathrm{cNo} \left(
            \sigma_\mathrm{cName='DBS'} (\mathrm{course})
        \right), \]
        接下来, 我们将 sc 表和该结果基于 cNo 做一个自然连接,
        于是没有选择数据库课程的选课记录将会作为悬浮的元组被剔除,
        \[ \mathrm{sc} \Join_\mathrm{cNo} \pi_\mathrm{cNo} \left(
            \sigma_\mathrm{cName='DBS'} (\mathrm{course})
        \right) \]
        接下来, 我们将其投影到 sNo 属性上,
        \[ \pi_\mathrm{sNo} \left(
            \mathrm{sc} \Join_\mathrm{cNo} \pi_\mathrm{cNo} \left(
            \sigma_\mathrm{cName='DBS'} (\mathrm{course})
        \right)
        \right), \]
        这就是所有选择了数据库的学生的学号,
        为了得到他们的姓名, 我们将其基于 sNo 属性与 student 表做一个自然连接,
        并将其投影到 sName 属性上, 于是
        \[ \pi_\mathrm{sName} \left(
            \mathrm{student} \Join_\mathrm{sNo}
            \pi_\mathrm{sNo} \left(
                \mathrm{sc} \Join_\mathrm{cNo} \pi_\mathrm{cNo} \left(
                    \sigma_\mathrm{cName='DBS'} (\mathrm{course})
                \right)
            \right)
        \right), \]
        即为所求.
    \end{sol}
\end{example}

\begin{example}
    查询信息学院 (SIS) 选修了科学技术简史 (A brief History of Science
    \& Technology, HST) 课程的学生姓名.
    \begin{sol}
        我们首先获取信息学院的元组, 并将其投影到 dNo 属性上,
        \[ \pi_\mathrm{dNo} \left(
            \sigma_{\mathrm{dName}=\mathrm{SIS}}(\mathrm{department})
        \right), \]
        然后将其与 student 表基于 dNo 属性进行自然连接,
        获得所有信息学院的学生信息:
        \[ \mathrm{student} \Join_\mathrm{dNo} \pi_\mathrm{dNo} \left(
            \sigma_{\mathrm{dName}=\mathrm{SIS}}(\mathrm{department})
        \right), \]
        这张表的属性为 (sNo, sName, sex, age, dNo),
        其中所有记录的 dNo 字段的值全为信息学院的编号.
        接下来我们获取科学技术简史课程的元组, 在 course 表中进行选择
        并进行投影:
        \[ \pi_\mathrm{cNo} \left(
            \sigma_\mathrm{cName = 'HST'}(\mathrm{course})
        \right), \]
        然后将其与 sc 表进行基于 cNo 进行自然连接,
        \[ \mathrm{sc} \Join_\mathrm{cNo}
        \pi_\mathrm{cNo} \left(
            \sigma_\mathrm{cName = 'HST'}(\mathrm{course})
        \right), \]
        该表的属性集为 (sNo, cNo, score, recordDate),
        其中所有记录的 cNo 值为科学技术简史的课程编号.
        接下来把它投影到 sNo 属性上, 得到所有选修了科学技术简史的学生的
        学号, 然后基于 sNo 对这两张表进行自然连接,
        \[ \left(\mathrm{student} \Join_\mathrm{dNo} \pi_\mathrm{dNo} \left(
            \sigma_{\mathrm{dName}=\mathrm{SIS}}(\mathrm{department})
        \right)\right) \Join_\mathrm{sNo} \left( \pi_\mathrm{sNo} \left(
            \mathrm{sc} 
            \Join_\mathrm{cNo}
            \pi_\mathrm{cNo} \left(
                \sigma_\mathrm{cName = 'HST'}(\mathrm{course})
            \right)
        \right)\right), \]
        这就得到选择了科学技术简史, 且在信息学院的学生的信息了, 把它投影到
        sName 属性上, 
        \[ \pi_\mathrm{sName} \left(
        \begin{matrix}
                & \left(\mathrm{student} \Join_\mathrm{dNo} \pi_\mathrm{dNo} \left(
                \sigma_{\mathrm{dName}=\mathrm{SIS}}(\mathrm{department})
            \right)\right) \\ 
            & \Join_\mathrm{sNo} \left( \pi_\mathrm{sNo} \left(
                \mathrm{sc} 
                \Join_\mathrm{cNo}
                \pi_\mathrm{cNo} \left(
                    \sigma_\mathrm{cName = 'HST'}(\mathrm{course})
                \right)
            \right)\right)
        \end{matrix}\right) \]
        即为所求.
    \end{sol}
\end{example}

\begin{example}
    查询选修了数据结构 (Data Structures, DS) 课程并且不及格的学生姓名.
    \begin{sol}
        我们首先获取数据结构课程的元组, 并将其投影到 cNo 上,
        \[ \pi_\mathrm{cNo} \left(
            \sigma_\mathrm{cName = 'DS'}\left(
                \mathrm{course}
            \right)
        \right), \]
        然后将其与 sc 表格基于 cNo 属性做自然连接, 就能得到一个数据结构课程
        的选课关系了, 在此基础上, 我们筛选出成绩为不合格的元组,
        并将其投影到 sNo 上,
        \[ \pi_\mathrm{sNo}\left(\sigma_{\mathrm{score < 60}} \left(
            \pi_\mathrm{cNo} \left(
            \sigma_\mathrm{cName = 'DS'}\left(
                \mathrm{course}
            \right)
        \right)
        \Join_\mathrm{cNo} \mathrm{sc}
        \right)\right), \]
        这就是所有的数据成绩不合格的学生的学号,
        接下来将其与 student 表基于 sNo 做自然连接, 并把结果投影到 sName,
        \[ \pi_\mathrm{sName} \left(
            \left(\pi_\mathrm{sNo}\left(\sigma_{\mathrm{score < 60}} \left(
            \pi_\mathrm{cNo} \left(
            \sigma_\mathrm{cName = 'DS'}\left(
                \mathrm{course}
            \right)
        \right)
        \Join_\mathrm{cNo} \mathrm{sc}
        \right)\right)\right) \Join_\mathrm{sNo} \mathrm{student}
        \right), \]
        这就是我们想要的.
    \end{sol}
\end{example}

\begin{example}
    查询计算机学院 (school of computer science, CS) 选修了
    概率论 (probability theory, PT) 课程且成绩大于等于 80 分的学生姓名.
    \begin{sol}
        
    \end{sol}
\end{example}

\newpage
\thispagestyle{empty}

\chapter{SQL 基础}

SQL 是\textbf{结构化查询语言} (Structured Query Language) 的缩写,
是一种综合性的数据库语言.
它的前身是结构化查询语言 (Stuructured English QUEry Language, SEQUEL),
在美国国家标准学会 (American National Standards Institute, ANSI) 和国际标准化组织
(International Standards Organization, ISO) 的共同努力下实现了 SQL 的标准化.

关于 SQL 的历史我们不再赘述, 感兴趣的读者可以自行了解. 本章我们以 PostgresSQL 为例
介绍一些基础的 SQL 语法, 需要注意的是, 各种 SQL 实现实际上都遵循着大体上相似的原则,
因此如果你的课程并不主要使用 PostgresSQL, 而是使用 Oracle 或者 MySQL 这样的其他的
DBMS 软件, 你依然可以参考本书来完成一些基本的 SQL 语法的学习, 在需要学习特定的 SQL 实现
的特性的时候, 再转到更专业更深入的材料中学习.

\section{SQL 中的数据定义和数据类型}

\subsection{SQL 中的 \lstinline|CREATE TABLE| 命令}

\lstinline|CREATE TABLE| 命令用于指定一个新关系, 为此, 你需要指定新关系的名称、
属性及其类型和一些约束条件 (如果需要的话).

\begin{example} 
    下述命令创建了一个 “天气” 关系 (方便起见, 我们以后都把关系称作\textbf{表}, 即 table),
    它有五个属性 (我们以后把属性称为\textbf{列}或者字段, 即 column, 字段是在
    Microsoft Access 中对关系的属性的称呼), 分别是城市 (city)、最高温度 (high temperature, temp\_hi)、最低温度 (low temperature, temp\_lo)、
    降水 (precipitation) 和日期 (date).
\begin{lstlisting}
CREATE TABLE weather (
    city varchar(80),
    temp_lo int,
    temp_hi int,
    prcp real,
    date date
);
\end{lstlisting}
\end{example}

\section{SQL 中的基本检索查询}

\begin{lstlisting}
department(dNo,dName,officeRoom,homepage)
student(sNo,sName,sex,age,dNo)
course(cNo,cName,cPNo,credit,dNo)
sc(sNo,cNo,score,recordDate)
\end{lstlisting}


\subsection{基本 SQL 查询的 \lstinline|SELECT-FROM-WHERE| 结构}

\lstinline|SELECT| 语句的基本形式也称为\textbf{映射} (mapping) 或
\lstinline|SELECT-FROM-WHERE| 块 (select-from-where block). 它的形式为
\begin{lstlisting}
SELECT <AttributeList>
FROM   <TableList>
WHERE  <Condition>
\end{lstlisting}
其中, \lstinline|<AttributeList>| 是一个属性名称的列表, 查询将通过该列表来检索属性的值.

\begin{example}
    查询所有年龄大于等于20岁的学生学号、姓名
\begin{lstlisting}[language=SQL]
SELECT sNo, sName
FROM student
WHERE age >= 20;
\end{lstlisting}
\end{example}


\begin{example}
    查询所有姓钱的男生学号、姓名、出生年份.
    \begin{lstlisting}[language=SQL]
SELECT sNo, sName, EXTRACT(YEAR FROM CURRENT_DATE) - age AS birthYear
FROM student
WHERE sName LIKE '钱%' AND sex = '男';
    \end{lstlisting}
\end{example}

\begin{example}
    查询所有学分大于3的课程名称.
    \begin{lstlisting}[language=SQL]
SELECT cName
FROM course
WHERE credit > 3;
    \end{lstlisting}
\end{example}


\begin{example}
    查询所有没有被分配到任何学院的学生姓名.
    \begin{lstlisting}[language=SQL]
SELECT sName
FROM student
WHERE dNo IS NULL;
    \end{lstlisting}
\end{example}
\begin{example}
    查询所有尚未设置主页的学院名称.
    \begin{lstlisting}[language=SQL]
SELECT dName
FROM department
WHERE homepage IS NULL;
    \end{lstlisting}
\end{example}

\begin{example}
    查询各个学院的平均年龄；
    \begin{lstlisting}
SELECT dNo, AVG(age) AS Average_Age
FROM student
GROUP BY dNo;
    \end{lstlisting}
\end{example}

\begin{example}
    查询每个学生选修课程的平均分；
    \begin{lstlisting}[language=SQL]
SELECT AVG(sc) AS Average_Score
FROM sc
GEOUNP BY sNo;
    \end{lstlisting}
\end{example}
\begin{example}
    查询各课程的平均分；
\end{example}
\begin{example}
    查询各学院开设的课程门数；
\end{example}
\begin{example}
    查询各门课程选修人数。
\end{example}

\newpage
\thispagestyle{empty}

\chapter{函数依赖和关系数据库规范化的基础知识}

\section{函数依赖}

设 $R = \left\{ A_1, A_2, \cdots, A_n \right\}$ 是 $n$ 个属性组成的属性组,
我们也将其称为单个\textbf{泛关系模式} (universal relational schema). 本章
讨论的目的, 是建立一种符合 $R$ 的关系状态 $\mathcal{R}$.

\begin{definition}
    设 $X, Y$ 是 $R$ 的两个子集, 这就是说, $X$ 和 $Y$ 是 $R$ 中的两个子属性组,
    如果对于关系模式 $R$ 中任意时刻的一个可能的关系 $\mathcal{R}$,
    {\kaishu $\mathcal{R}$ 中任意的元组 $t_1$ 和 $t_2$, 都满足
    从 $t_1[X] = t_2[X]$ 能够推出 $t_1[Y] = t_2[Y]$}, 即
    \[ \forall t_1, t_2 \in \mathcal{R} \left(
        t_1[X] = t_2[X] \Rightarrow t_1[Y] = t_2[Y]
    \right), \]
    即 $\mathcal{R}$ 中不可能存在两个元组使得它们在 $X$ 上的属性值相同
    而在 $Y$ 上的属性值不同,
    则称属性组 $Y$ \textbf{函数依赖} (functional dependency) 于 $X$,
    记作 $X \to Y$.
\end{definition}

换言之, 属性组 $X$ 中的一个值能够唯一确定属性组 $Y$ 中的一个值.
这与我们在数学上接触过的函数的概念是一致的.
如果 $Y$ 不函数依赖于 $X$, 则记作 $X \nrightarrow Y$.
函数依赖定义中的 “任意” 说明, 函数依赖不是指关系模式的某个或者某些关系实例
满足约束条件, 而是指所有关系实例均要满足这一约束条件.

\begin{example}
    对于存储于学校教务系统的一个学生来说, 有一关系
    student(sNo, sName, sDepartment, sMajor), 
    在这一关系中, $\left\{\mathrm{sNo}\right\} \to \left\{
        \mathrm{sName}, \mathrm{sDepartment}, \mathrm{sMajor}
    \right\}$, 这就是说, 只要确定一个同学的学号, 就能够\textbf{唯一地确定}
    TA 的姓名、学院和专业, 例如, 如果一个学生 $s$ 满足
    \[ s[\mathrm{sNo}] = 2021114514, \]
    那么必然满足
    \[ s[\mathrm{sName}] = \mathrm{Strik0r}, \]
    \[ s[\mathrm{sDepartment}] = \mathrm{Software}, \] 
    \[ s[\mathrm{sMajor}] = \mathrm{Software\_Engineering}. \]
    你可以用图示的方法来明确的表达属性之间的函数依赖关系:
    \begin{figure}[H]
        \centering


        \tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        

        \begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
        %uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300
        
        
        % Text Node
        \draw (122,128) node [anchor=north west][inner sep=0.75pt]   [align=left] {sNo};
        % Text Node
        \draw (239,78) node [anchor=north west][inner sep=0.75pt]   [align=left] {sName};
        % Text Node
        \draw (239,128) node [anchor=north west][inner sep=0.75pt]   [align=left] {sDepartment};
        % Text Node
        \draw (239,174) node [anchor=north west][inner sep=0.75pt]   [align=left] {sMajor};
        % Connection
        \draw    (154,129.64) -- (233.21,98.58) ;
        \draw [shift={(236,97.48)}, rotate = 158.59] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (5.36,-2.57) -- (0,0) -- (5.36,2.57) -- cycle    ;
        % Connection
        \draw    (154,136.5) -- (233,136.5) ;
        \draw [shift={(236,136.5)}, rotate = 180] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (5.36,-2.57) -- (0,0) -- (5.36,2.57) -- cycle    ;
        % Connection
        \draw    (154,142.89) -- (233.18,171.8) ;
        \draw [shift={(236,172.83)}, rotate = 200.06] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (5.36,-2.57) -- (0,0) -- (5.36,2.57) -- cycle    ;
        
        \end{tikzpicture}
    \end{figure}
\end{example}

\begin{definition}
    关系模式 $R = \left\{A_1, A_2, \cdots, A_n \right\}$ 的一个属性集合
    $S \subset R$, 如果在任意的合法关系状态 $\mathcal{R}$ 中,
    对于任意的两个元组 $t_1, t_2$ 必有 $t_1[S] \ne t_2[S]$,
    则称 $S$ 是 $R$ 的一个\textbf{超键}.
\end{definition}

这就是说, 如果一个属性组是超键, 那么在合法的关系状态中, 元组的超键的值是唯一的,
即通过超键能够唯一地确定一个元组.

\begin{definition}
    关系模式 $R = \left\{ A_1, A_2, \cdots, A_n \right\}$
    的一个属性集合 $K \subset R$ 如果同时满足以下两个条件:
    \begin{enumerate}[label={${\arabic*}^\circ$}, itemsep=0pt]
        \item $\forall \mathcal{R}(R) \forall t_1 t_2 \left(
            t_1[K] \ne t_2[K]
        \right)$, 即 $K$ 是 $R$ 的一个超键.
        \item 对于 $K$ 中任意的一个属性 $A_i$, 属性组
        $K - \left\{ A_i \right\}$ 都不再是 $R$ 的超键.
    \end{enumerate}
    则称 $K$ 是 $R$ 的一个\textbf{键}.
\end{definition}

超键与键之间的关系, 就像上界与上确界之间的关系\footnote{
    如果读者想要了解有关有界数集的界与确界的更多内容,
    可以参考笔者编写的《数学分析》.
}. 上确界是最小上界,
同理, 键是不能再删除属性的超键.

如果一个关系模式具有多个键, 则把这些键称为候选键, 可以从中任意地选定一个作为\textbf{主键},
其他的候选键则称为辅键. 在关系型数据库中, 每个关系模式都必须有一个主键.

\begin{definition}[主属性]
    设 $R = \left\{A_1, A_2, \cdots, A_n\right\}$ 是一个关系模式,
    $K$ 是 $R$ 的一个候选键. 如果属性 $A_i \in K$, 即属性 $A_i$ 是键属性组
    $K$ 的成员, 那么称 $A_i$ 为 $R$ 的一个\textbf{主属性} (prime attribute).
    如果一个属性不是任何候选键的成员, 则称它为\textbf{非主属性} (nonprime attribute).
\end{definition}

\section{基于主键的范式}

{\captionof{table}{基于主键的范式} % 表格标题
\label{基于主键的范式} % 交叉引用标签
\begin{longtable}{p{8em}p{14em}p{14em}}
    \hline
    % 表头
    \textbf{范式} & \textbf{内容} & \textbf{校正方法} \\
    \hline
    \endhead
    \hline
    \endfoot

    % 表格内容
    第一范式 1NF 
    & 关系中不应该包含多值属性或嵌套关系 
    & 为每个多值属性或嵌套关系组建新关系 \\
    第二范式 2NF
    & 对于其主键包含多个属性的关系, 不应该存在非主属性对主属性的部分依赖
    & 分解原来的关系, 为每个部分键及其相关属性建立一个新关系, 确保在一个关系中
    保留原始的主键以及完全函数依赖于它的任何属性 \\ 
    第三范式 3NF
    & 关系中不应该有一个非键属性对另一个非键属性的函数依赖,
    即不应该有一个非键属性传递依赖于主键 
    & 分解原来的关系并建立一个关系, 其中包括的非键属性可以函数确定
    其他的非键属性.
\end{longtable}}

\section{Boyce-Codd 范式}

\begin{example}
    现有关系模式: $R(A, B, C, D, E)$, 存在函数依赖 
    $A B C \rightarrow D E, A C \rightarrow D, D \rightarrow E$.
    问:
    \begin{enumerate}[label={$\left.\arabic*\right)$}, itemsep=0pt]
        \item 关系 $R$ 属于第几范式?
        \begin{sol}
            $R \in \mathrm{1NF}$, 这是因为
            \[ (ABC)^+ = \left\{ A,B,C,D,E \right\}, \]
            因此 $ABC$ 是 $R$ 的键, 不妨选取其为主键,
            则 $A,B,C$ 为主属性, $D, E$ 为非主属性,
            不难发现由于 $AD \to D$,
            因此存在 $ABC \xrightarrow{\mathrm{Partial}} D$,
            即非主属性 $D$ 对键 $ABC$ 的部分依赖.
        \end{sol}
        \item 若关系 $R$ 不属于 BCNF, 请将其逐步分解为 BCNF.
        要求写出每一级范式的分解过程.
        \begin{itemize}[itemsep=0pt]
            \item $R_{21} = (\left\{A,C,D,E\right\}, \left\{
                AC \to D, D \to E
            \right\})$, $R_{22} = (\left\{ A,B,C \right\},
            \left\{
                ABC \to ABC
            \right\})$.
            \item 注意到在 $R_{21}$ 中存在非主属性 $E$ 对主属性 $AC$
            的传递依赖, 即 $AC \xrightarrow{\mathrm{Transitive}} E$,
            于是 $R_{21} \notin \mathrm{3NF}$.

            $R_{31} = \left(
                \left\{
                    A, C, D
                \right\}, \left\{
                    AC \to D
                \right\}
            \right)$, $R_{32} = \left(
                \left\{ D,E \right\}, \left\{
                    D \to E
                \right\}
            \right)$, $R_{33} = R_{22}$.
            \item 注意到此时 $R_{31}$, $R_{32}$, $R_{33}$ 中同时也不存在
            主属性对主键的部分依赖, 因此它实际上已经满足 Boyce-Codd 范式,
            即 $R_{31}, R_{32}, R_{33} \in \mathrm{BCNF}$.
        \end{itemize}
    \end{enumerate}
\end{example}

\begin{example}
    现有关系模式: $R(A, B, C, D, E, F)$,
    存在函数依赖 
    $B \rightarrow C, A \rightarrow D, 
    A B \rightarrow E, D \rightarrow F$. 问:
    \begin{enumerate}[label={$\left.\arabic*\right)$}, itemsep=0pt]
        \item 关系 $R$ 属于第几范式?
        \begin{sol}
            由于
            \[ (AB)^+ = \left\{
                A,B, C, D, E, F
            \right\}, \]
            因此 $AB$ 为关系 $R$ 的键 (容易验证
            $B^+ = \left\{ B,C \right\}$,
            $A^+ = \left\{ A, D, F \right\}$,
            它们都不是超键), 选择其作为主键.
            由于 $B \to C$, 因此存在非主属性 $C$ 对主键 $AB$
            的部分依赖 $AB \xrightarrow{\mathrm{Partial}} C$.
            这就是说, $R \in \mathrm{1NF}$.
        \end{sol}
        \item 若关系 $R$ 不属于 BCNF, 请将其逐步分解为 BCNF.
        要求写出每一级范式的分解过程.
        \begin{itemize}[itemsep=0pt]
            \item 为了消除非主属性对主键的部分依赖, 我们令
            \[ R_{21} = \left(
                \left\{B, C\right\}, \left\{
                    B \to C
                \right\}
            \right), \] \[ R_{22} = \left(
                \left\{ A, D, F \right\},
                \left\{ A \to D, D \to F \right\}
            \right), \] \[ R_{23} = \left(
                \left\{ A, B, E \right\},
                \left\{
                    AB \to E
                \right\}
            \right). \] 则它们属于第二范式, 即 $R_{21}, R_{22}, R_{23} \in \mathrm{2NF}$.
            \item 注意到在 $R_{22}$ 中, 由于 $A \to D, D \to F$,
            即存在非主属性 $F$ 对键 $A$ 的传递依赖 $A \xrightarrow{\mathrm{Transitive}} F$,
            因此 $R_{22} \notin \mathrm{3NF}$, 为此, 令
            \[ R_{31} = R_{21}, \] \[ R_{32} = \left(
                \left\{ A, D \right\}, \left\{ A \to D \right\}
            \right), \]  \[ R_{33} = \left(
                \left\{ D, F \right\}, \left\{ D \to F \right\}
            \right),\] \[ R_{34} = R_{23}, \] 则它们属于第三范式,
            即 $R_{31}, \cdots, R_{34} \in \mathrm{3NF}$.
            \item  $R_{31}, \cdots, R_{34} \in \mathrm{BCNF}$,
            这是因为在它们中不存在主属性对主键的部分依赖.
        \end{itemize}
    \end{enumerate}
\end{example}

\chapter{数据库设计的规范化问题}

\begin{figure}[H]
    \centering


    \tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        

    \begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
    %uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300

    %Shape: Rectangle [id:dp07523731865033279] 
    \draw   (87,100) -- (257,100) -- (257,245.5) -- (87,245.5) -- cycle ;
    %Straight Lines [id:da3910203522703485] 
    \draw    (87,132) -- (257,132) ;

    %Straight Lines [id:da8499453457607233] 
    \draw    (257,172.75) -- (416,172.75) ;
    \draw [shift={(419,172.75)}, rotate = 180] [fill={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.08]  [draw opacity=0] (5.36,-2.57) -- (0,0) -- (5.36,2.57) -- cycle    ;
    %Shape: Rectangle [id:dp9006099344965471] 
    \draw   (419,101.25) -- (589,101.25) -- (589,246.75) -- (419,246.75) -- cycle ;
    %Straight Lines [id:da5642236534532944] 
    \draw    (419,133.25) -- (589,133.25) ;


    % Text Node
    \draw (171.5,187.25) node   [align=left] {\begin{minipage}[lt]{104.04pt}\setlength\topsep{0pt}
    \mbox{-} dNo (PK)\\\mbox{-} dName
    \end{minipage}};
    % Text Node
    \draw (171.5,117.75) node   [align=left] {\begin{minipage}[lt]{106.76pt}\setlength\topsep{0pt}
    \begin{center}
    Department
    \end{center}

    \end{minipage}};
    % Text Node
    \draw (503.5,119) node   [align=left] {\begin{minipage}[lt]{106.76pt}\setlength\topsep{0pt}
    \begin{center}
    Student
    \end{center}

    \end{minipage}};
    % Text Node
    \draw (503.5,188.5) node   [align=left] {\begin{minipage}[lt]{104.04pt}\setlength\topsep{0pt}
    \mbox{-} sNo (PK)\\\mbox{-} sName
    \end{minipage}};


    \end{tikzpicture}
\caption{}
\end{figure}

\chapter{事务处理}



\input{LateX_tem/appendix.tex}

\begin{thebibliography}{1}
    \addcontentsline{toc}{chapter}{参考文献}
    \bibitem{数据库系统基础}
    [美] Rames Elmasri, [美] Shamkant B. Navathe. 数据库系统基础: 第 7 版
    (Fundamentals of Database Systems, 7e)[M].
    陈宗斌等译. 北京: 清华大学出版社, 2020.
\end{thebibliography}

\input{LateX_tem/endpage.tex}

\end{document}